package power

import (
	"encoding/json"
	"fmt"
	"io"
	"os"

	"github.com/OpenCHAMI/magellan/internal/util"
	"github.com/OpenCHAMI/magellan/pkg/crawler"
	"gopkg.in/yaml.v3"

	"github.com/rs/zerolog/log"
	"github.com/stmcginnis/gofish"
	"github.com/stmcginnis/gofish/redfish"
)

type Node struct {
	ClusterID string `yaml:"cluster_id"`
	BmcIP     string `yaml:"bmc_ip"`
	NodeID    string `yaml:"node_id"`
}
type CrawlableNode struct {
	ClusterID  string
	ConnConfig crawler.CrawlerConfig
	NodeID     string
}
type PowerInfo struct {
	ClusterID string
	State     redfish.PowerState
}

// Hold onto the current set of open clients, so we don't continually have to log into and out of BMCs
var savedClients map[string]*gofish.APIClient

// ParseInventory reads parameters relevant to power control from the kind of YAML file generated by the `collect` command.
//
// Parameters:
//   - filename: the path of the YAML file to parse for inventory data, or `-` for stdin.
//
// Returns:
//   - []Node: A slice of structs containing relevant details for connecting to a node via its BMC.
//   - error: An error object if any error occurs during the connection or reset process.
func ParseInventory(filename string, format string) ([]Node, error) {
	// Read `collect`ed data from YAML file
	var (
		contents []byte
		err      error
	)
	if filename == "-" {
		filename = "[stdin]"
		contents, err = io.ReadAll(os.Stdin)
	} else {
		contents, err = os.ReadFile(filename)
	}
	if err != nil {
		log.Error().Err(err).Msgf("failed to read collected inventory from %s", filename)
		return nil, err
	}

	var inventory []struct {
		ID      string                    `json:"ID" yaml:"ID"`
		FQDN    string                    `json:"FQDN" yaml:"FQDN"`
		Systems []crawler.InventoryDetail `json:"Systems" yaml:"Systems"`
	}
	switch format {
	case util.FORMAT_JSON:
		err = json.Unmarshal(contents, &inventory)
	case util.FORMAT_YAML:
		err = yaml.Unmarshal(contents, &inventory)
	default:
		err = fmt.Errorf("unknown input format: %s", format)
	}
	if err != nil {
		log.Error().Err(err).Msgf("failed to unmarshal contents of collected inventory file %s", filename)
		return nil, err
	}

	nodelist := make([]Node, 0, len(inventory))
	for i := range inventory {
		systems := inventory[i].Systems
		for j := range systems {
			nodelist = append(nodelist, Node{
				// TODO: This assumes indices in the Systems list correspond to nodes' "â€¦nX" xname components.
				// If the list is reordered at any point, or if nodes were missing during crawl, this may not hold!
				// FIXME: This assumes strict xname formatting! To become xname-agnostic, this should be
				// replaced with some other cluster-wide ID (which the BMC/ComputerSystem itself won't know, so
				// it'll have to be generated/looked up from somewhere else).
				ClusterID: fmt.Sprintf("%sn%d", inventory[i].ID, j),
				BmcIP:     inventory[i].FQDN,
				NodeID:    systems[j].NodeID,
			})
		}
	}

	return nodelist, nil
}

// ResetComputerSystem connects to a BMC (Baseboard Management Controller) using the provided configuration,
// retrieves the ServiceRoot, and retrieves the list of supported reset types for the target ComputerSystem.
//
// Parameters:
//   - node: A CrawlableNode struct containing the node's xname, index within the BMC, and a CrawlerConfig to connect to the BMC.
//
// Returns:
//   - []redfish.ResetType: a slice of Redfish reset types supported on the node.
//   - error: An error object if any error occurs during the connection or reset process.
func GetResetTypes(node CrawlableNode) ([]redfish.ResetType, error) {
	log.Debug().Msgf("polling %s for reset types", node.ConnConfig.URI)

	// Obtain an active client
	client, err := GetBMCSession(node.ConnConfig)
	if err != nil {
		return nil, err
	}

	// Determine reset types for the target computer system
	rf_systems, err := client.GetService().Systems()
	if err != nil {
		return nil, err
	}
	var system *redfish.ComputerSystem
	for i := range rf_systems {
		if rf_systems[i].ID == node.NodeID {
			system = rf_systems[i]
			break
		}
	}
	return system.SupportedResetTypes, nil
}

// PollBMCPowerStates connects to a BMC (Baseboard Management Controller) using the provided configuration,
// retrieves the ServiceRoot, and retrieves the current power state for each ComputerSystem in each Chassis.
//
// Parameters:
//   - node: A CrawlableNode struct containing the target node's xname, index within the BMC, and a crawler.CrawlerConfig struct.
//
// Returns:
//   - redfish.PowerState: The current power state of the node. (Custom string subtype)
//   - error: An error object if any error occurs during the connection or retrieval process.
func GetPowerState(node CrawlableNode) (redfish.PowerState, error) {
	log.Debug().Msgf("polling %s for power states", node.ConnConfig.URI)

	// Obtain an active client
	client, err := GetBMCSession(node.ConnConfig)
	if err != nil {
		return "", err
	}

	// Determine power details for the target computer system
	rf_systems, err := client.GetService().Systems()
	if err != nil {
		return "", err
	}
	var system *redfish.ComputerSystem
	for i := range rf_systems {
		if rf_systems[i].ID == node.NodeID {
			system = rf_systems[i]
			break
		}
	}
	return system.PowerState, nil
}

// ResetComputerSystem connects to a BMC (Baseboard Management Controller) using the provided configuration,
// retrieves the ServiceRoot, and issues a reset of the specified type to a particular computer system.
//
// Parameters:
//   - node: A CrawlableNode struct containing the node's xname, index within the BMC, and a CrawlerConfig to connect to the BMC.
//   - resetType: A redfish.ResetType parameter, specifying the manner in which the target ComputerSystem should be reset.
//
// Returns:
//   - error: An error object if any error occurs during the connection or reset process.
func ResetComputerSystem(node CrawlableNode, resetType redfish.ResetType) error {
	log.Debug().Msgf("resetting computer system %s: %s", node.ClusterID, resetType)

	client, err := crawler.GetBMCClient(node.ConnConfig)
	if err != nil {
		return err
	}
	defer client.Logout()

	// Obtain the ServiceRoot
	rf_service := client.GetService()
	log.Debug().Msgf("found ServiceRoot %s. Redfish Version %s", rf_service.ID, rf_service.RedfishVersion)

	// Select the relevant ComputerSystem
	rf_systems, err := rf_service.Systems()
	if err != nil {
		return err
	}
	var rf_compsys *redfish.ComputerSystem
	for i := range rf_systems {
		if rf_systems[i].ID == node.NodeID {
			rf_compsys = rf_systems[i]
			break
		}
	}

	// Reset the system
	return rf_compsys.Reset(resetType)
}

// GetBMCSession returns an already-active gofish BMC client, creating a new one if necessary.
// This facilitates keeping the clients open for efficiency.
//
// Parameters:
//   - config: A CrawlerConfig struct containing the URI, username, password, and other connection details.
//
// Returns: none.
func GetBMCSession(config crawler.CrawlerConfig) (*gofish.APIClient, error) {
	client, exists := savedClients[config.URI]
	if exists {
		log.Debug().Msgf("found existing client for %s", config.URI)
	} else {
		if savedClients == nil {
			savedClients = make(map[string]*gofish.APIClient)
		}
		var err error
		client, err = crawler.GetBMCClient(config)
		if err != nil {
			return nil, err
		}
		log.Debug().Msgf("created new client for %s", config.URI)
		savedClients[config.URI] = client
	}
	return client, nil
}

// LogoutBMCSessions logs out all active gofish BMC clients, which we normally like to keep open for efficiency.
// Logging out should be done as a post-execution cleanup step.
//
// Parameters: none.
//
// Returns: none.
func LogoutBMCSessions() {
	for uri, client := range savedClients {
		log.Debug().Msgf("logging out client for %s", uri)
		client.Logout()
	}
}
