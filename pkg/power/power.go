package power

import (
	"fmt"
	"io"
	"os"

	"github.com/OpenCHAMI/magellan/pkg/crawler"
	"gopkg.in/yaml.v3"

	"github.com/rs/zerolog/log"
	"github.com/stmcginnis/gofish"
	"github.com/stmcginnis/gofish/redfish"
)

type NodeViaBMC struct {
	Xname     string `yaml:"xname"`
	Bmc_IP    string `yaml:"bmc_ip"`
	Bmc_Index int    `yaml:"bmc_index"`
}
type CrawlableNode struct {
	Xname      string
	ConnConfig crawler.CrawlerConfig
	BmcIndex   int
}
type PowerInfo struct {
	Xname string
	State redfish.PowerState
}

// Hold onto the current set of open clients, so we don't continually have to log into and out of BMCs
var savedClients map[string]*gofish.APIClient

// ParseInventory reads parameters relevant to power control from the kind of YAML file generated by the `collect` command.
//
// Parameters:
//   - filename: the path of the YAML file to parse for inventory data, or `-` for stdin.
//
// Returns:
//   - []NodeViaBMC: A slice of structs containing relevant details for connecting to a node via its BMC.
//   - error: An error object if any error occurs during the connection or reset process.
func ParseInventory(filename string) ([]NodeViaBMC, error) {
	// Read `collect`ed data from YAML file
	var (
		contents []byte
		err      error
	)
	if filename == "-" {
		filename = "[stdin]"
		contents, err = io.ReadAll(os.Stdin)
	} else {
		contents, err = os.ReadFile(filename)
	}
	if err != nil {
		log.Error().Err(err).Msgf("failed to read collected inventory from %s", filename)
		return nil, err
	}

	var inventory []struct {
		ID      string                    `yaml:"ID"`
		FQDN    string                    `yaml:"FQDN"`
		Systems []crawler.InventoryDetail `yaml:"Systems"`
	}
	err = yaml.Unmarshal(contents, &inventory)
	if err != nil {
		log.Error().Err(err).Msgf("failed to unmarshal contents of collected inventory file %s", filename)
		return nil, err
	}

	nodelist := make([]NodeViaBMC, 0, len(inventory))
	for i := range inventory {
		systems := inventory[i].Systems
		for j := range systems {
			nodelist = append(nodelist, NodeViaBMC{
				Xname:     fmt.Sprintf("%sn%d", inventory[i].ID, systems[j].Bmc_Index-1),
				Bmc_IP:    inventory[i].FQDN,
				Bmc_Index: systems[j].Bmc_Index,
			})
		}
	}

	return nodelist, nil
}

// ResetComputerSystem connects to a BMC (Baseboard Management Controller) using the provided configuration,
// retrieves the ServiceRoot, and retrieves the list of supported reset types for the target ComputerSystem.
//
// Parameters:
//   - node: A CrawlableNode struct containing the node's xname, index within the BMC, and a CrawlerConfig to connect to the BMC.
//
// Returns:
//   - []redfish.ResetType: a slice of Redfish reset types supported on the node.
//   - error: An error object if any error occurs during the connection or reset process.
func GetResetTypes(node CrawlableNode) ([]redfish.ResetType, error) {
	log.Debug().Msgf("polling %s for reset types", node.ConnConfig.URI)

	// Obtain an active client
	client, err := GetBMCSession(node.ConnConfig)
	if err != nil {
		return nil, err
	}

	// Determine reset types for the target computer system
	rf_systems, err := client.GetService().Systems()
	if err != nil {
		return nil, err
	}
	system := rf_systems[node.BmcIndex-1]
	return system.SupportedResetTypes, nil
}

// PollBMCPowerStates connects to a BMC (Baseboard Management Controller) using the provided configuration,
// retrieves the ServiceRoot, and retrieves the current power state for each ComputerSystem in each Chassis.
//
// Parameters:
//   - node: A CrawlableNode struct containing the target node's xname, index within the BMC, and a crawler.CrawlerConfig struct.
//
// Returns:
//   - redfish.PowerState: The current power state of the node. (Custom string subtype)
//   - error: An error object if any error occurs during the connection or retrieval process.
func GetPowerState(node CrawlableNode) (redfish.PowerState, error) {
	log.Debug().Msgf("polling %s for power states", node.ConnConfig.URI)

	// Obtain an active client
	client, err := GetBMCSession(node.ConnConfig)
	if err != nil {
		return "", err
	}

	// Determine power details for the target computer system
	rf_systems, err := client.GetService().Systems()
	if err != nil {
		return "", err
	}
	system := rf_systems[node.BmcIndex-1]
	return system.PowerState, nil
}

// ResetComputerSystem connects to a BMC (Baseboard Management Controller) using the provided configuration,
// retrieves the ServiceRoot, and issues a reset of the specified type to a particular computer system.
//
// Parameters:
//   - node: A CrawlableNode struct containing the node's xname, index within the BMC, and a CrawlerConfig to connect to the BMC.
//   - resetType: A redfish.ResetType parameter, specifying the manner in which the target ComputerSystem should be reset.
//
// Returns:
//   - error: An error object if any error occurs during the connection or reset process.
func ResetComputerSystem(node CrawlableNode, resetType redfish.ResetType) error {
	log.Debug().Msgf("resetting computer system %s: %s", node.Xname, resetType)

	client, err := crawler.GetBMCClient(node.ConnConfig)
	if err != nil {
		return err
	}
	defer client.Logout()

	// Obtain the ServiceRoot
	rf_service := client.GetService()
	log.Debug().Msgf("found ServiceRoot %s. Redfish Version %s", rf_service.ID, rf_service.RedfishVersion)

	// Select the relevant ComputerSystem
	rf_systems, err := rf_service.Systems()
	if err != nil {
		return err
	}
	rf_compsys := rf_systems[node.BmcIndex-1]

	// Reset the system
	return rf_compsys.Reset(resetType)
}

// GetBMCSession returns an already-active gofish BMC client, creating a new one if necessary.
// This facilitates keeping the clients open for efficiency.
//
// Parameters:
//   - config: A CrawlerConfig struct containing the URI, username, password, and other connection details.
//
// Returns: none.
func GetBMCSession(config crawler.CrawlerConfig) (*gofish.APIClient, error) {
	client, exists := savedClients[config.URI]
	if exists {
		log.Debug().Msgf("found existing client for %s", config.URI)
	} else {
		if savedClients == nil {
			savedClients = make(map[string]*gofish.APIClient)
		}
		var err error
		client, err = crawler.GetBMCClient(config)
		if err != nil {
			return nil, err
		}
		log.Debug().Msgf("created new client for %s", config.URI)
		savedClients[config.URI] = client
	}
	return client, nil
}

// LogoutBMCSessions logs out all active gofish BMC clients, which we normally like to keep open for efficiency.
// Logging out should be done as a post-execution cleanup step.
//
// Parameters: none.
//
// Returns: none.
func LogoutBMCSessions() {
	for uri, client := range savedClients {
		log.Debug().Msgf("logging out client for %s", uri)
		client.Logout()
	}
}
